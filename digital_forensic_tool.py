import argparse
import hashlib
import pandas as pd
import socket
from datetime import datetime, timezone
import os
import tkinter as tk
from tkinter import filedialog, messagebox

# =========================
# GLOBAL AUDIT TRAIL
# =========================
AUDIT_LOG = []

def log_event(message, level="INFO"):
    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")
    AUDIT_LOG.append(f"[{timestamp}] {level}: {message}")

# =========================
# HASHING (CLO3)
# =========================
def hash_evidence(file_path):
    sha256 = hashlib.sha256()
    with open(file_path, "rb") as f:
        for block in iter(lambda: f.read(4096), b""):
            sha256.update(block)
    return sha256.hexdigest()

# =========================
# NETWORK FORENSIC ANALYSIS (WITH TIMELINE)
# =========================
def analyze_network(csv_file):
    df = pd.read_csv(csv_file)

    required = {"Timestamp", "Source", "Destination", "Protocol"}
    if not required.issubset(df.columns):
        raise ValueError("Network CSV must contain Timestamp, Source, Destination, Protocol")

    df["Timestamp"] = pd.to_datetime(df["Timestamp"], utc=True)

    results = []
    for src, group in df.groupby("Source"):
        if len(group) >= 3:
            results.append({
                "source": src,
                "destination": group["Destination"].iloc[0],
                "protocol": group["Protocol"].iloc[0],
                "frequency": len(group),
                "first_seen": group["Timestamp"].min(),
                "last_seen": group["Timestamp"].max(),
                "flag": "High frequency connections in short time window"
            })

    log_event("Network traffic analyzed with timeline")
    return results

# =========================
# AUTH LOG ANALYSIS (WITH TIMELINE)
# =========================
def analyze_logs(csv_file):
    df = pd.read_csv(csv_file)

    required = {"Timestamp", "IP", "Status"}
    if not required.issubset(df.columns):
        raise ValueError("Auth log CSV must contain Timestamp, IP, Status")

    df["Timestamp"] = pd.to_datetime(df["Timestamp"], utc=True)
    failed = df[df["Status"] == "FAIL"]

    results = []
    for ip, group in failed.groupby("IP"):
        results.append({
            "ip": ip,
            "attempts": len(group),
            "first_attempt": group["Timestamp"].min(),
            "last_attempt": group["Timestamp"].max(),
            "duration": int((group["Timestamp"].max() - group["Timestamp"].min()).total_seconds() / 60)
        })

    log_event("Authentication logs analyzed with timeline")
    return results

# =========================
# HTML REPORT (UPDATED CSS ONLY)
# =========================
def generate_html_report(data):
    os.makedirs("reports", exist_ok=True)
    path = f"reports/forensic_report_{data['case_id']}.html"

    html = f"""
<!DOCTYPE html>
<html>
<head>
<title>PySecureTrace Forensic Report</title>
<style>
body {{
    font-family: Arial, Helvetica, sans-serif;
    background-color: #f7f9fc;
    margin: 40px;
    color: #2c3e50;
}}

h1 {{
    text-align: center;
    margin-bottom: 5px;
}}

h2 {{
    margin-bottom: 10px;
}}

.section {{
    background-color: #ffffff;
    padding: 15px;
    margin-bottom: 25px;
    border: 1px solid #ccc;
}}

table {{
    width: 100%;
    border-collapse: collapse;
    margin-top: 10px;
}}

th {{
    background-color: #f2f2f2;
    color: #000;
    border: 1px solid #000;
    padding: 8px;
}}

td {{
    border: 1px solid #000;
    padding: 8px;
    text-align: center;
}}

pre {{
    background-color: #f4f6f7;
    padding: 10px;
    font-size: 12px;
}}

.footer {{
    text-align: center;
    font-size: 12px;
    color: #7b7d7d;
    margin-top: 30px;
}}
</style>
</head>

<body>

<h1>Automated Digital Forensic Analysis Report</h1>
<p style="text-align:center;">Generated by <b>PySecureTrace</b></p>

<div class="section">
<h2>1. Header & Metadata</h2>
<ul>
<li><b>Date (UTC):</b> {data['time']}</li>
<li><b>Case ID:</b> {data['case_id']}</li>
<li><b>Examiner:</b> {data['examiner']}</li>
<li><b>System Hostname:</b> {data['host']}</li>
</ul>
</div>

<div class="section">
<h2>2. Evidence Integrity</h2>
<p><b>Ingress Hash (SHA-256):</b> {data['hash_before']}</p>
<p><b>Egress Hash (SHA-256):</b> {data['hash_after']}</p>
<p><b>Integrity Status:</b> MATCHED</p>
</div>

<div class="section">
<h2>3. Executive Summary</h2>
<ul>
<li>{len(data['network'])} suspicious network sources detected</li>
<li>{len(data['logs'])} IPs involved in failed authentication attempts</li>
</ul>
</div>

<div class="section">
<h2>4. Network Forensic Findings (Timeline-Based)</h2>
<table>
<tr>
<th>Source IP</th>
<th>Destination</th>
<th>Protocol</th>
<th>Frequency</th>
<th>First Seen (UTC)</th>
<th>Last Seen (UTC)</th>
<th>Flag Reason</th>
</tr>
"""

    for n in data["network"]:
        html += f"""
<tr>
<td>{n['source']}</td>
<td>{n['destination']}</td>
<td>{n['protocol']}</td>
<td>{n['frequency']}</td>
<td>{n['first_seen']}</td>
<td>{n['last_seen']}</td>
<td>{n['flag']}</td>
</tr>
"""

    html += """
</table>
</div>

<div class="section">
<h2>5. Failed Login Analysis (Timeline)</h2>
<table>
<tr>
<th>IP Address</th>
<th>Attempts</th>
<th>First Attempt</th>
<th>Last Attempt</th>
<th>Duration (minutes)</th>
<th>Assessment</th>
</tr>
"""

    for l in data["logs"]:
        html += f"""
<tr>
<td>{l['ip']}</td>
<td>{l['attempts']}</td>
<td>{l['first_attempt']}</td>
<td>{l['last_attempt']}</td>
<td>{l['duration']}</td>
<td>Possible brute-force activity</td>
</tr>
"""

    html += """
</table>
</div>

<div class="section">
<h2>6. Audit Trail</h2>
<pre>
"""

    for log in AUDIT_LOG:
        html += log + "\n"

    html += """
</pre>
</div>

<div class="section">
<h2>7. Conclusion</h2>
<p>
Timeline correlation between abnormal network traffic and repeated authentication failures
indicates suspicious activity. Evidence integrity was preserved throughout the forensic process.
</p>
</div>

<div class="footer">
PySecureTrace | ITT593 Digital Forensics Project
</div>

</body>
</html>
"""

    with open(path, "w", encoding="utf-8") as f:
        f.write(html)

    return path

# =========================
# CORE WORKFLOW
# =========================
def run_forensics(net_file, log_file, case_id, examiner):
    log_event("Forensic process started")

    hash_before = hash_evidence(net_file)
    log_event("Ingress hash calculated")

    network = analyze_network(net_file)
    logs = analyze_logs(log_file)

    hash_after = hash_evidence(net_file)
    log_event("Egress hash calculated")

    report = generate_html_report({
        "time": datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC"),
        "case_id": case_id,
        "examiner": examiner,
        "host": socket.gethostname(),
        "hash_before": hash_before,
        "hash_after": hash_after,
        "network": network,
        "logs": logs
    })

    log_event("HTML report generated")
    print(f"[✓] Report generated: {report}")

# =========================
# GUI
# =========================
def gui_mode():
    def browse(entry):
        entry.delete(0, tk.END)
        entry.insert(0, filedialog.askopenfilename())

    def start():
        try:
            run_forensics(
                net_entry.get(),
                log_entry.get(),
                case_entry.get(),
                examiner_entry.get()
            )
            messagebox.showinfo("Success", "Report generated successfully!")
        except Exception as e:
            messagebox.showerror("Error", str(e))

    root = tk.Tk()
    root.title("PySecureTrace – Digital Forensic Tool")

    tk.Label(root, text="PySecureTrace – Digital Forensic Tool",
             font=("Arial", 14, "bold")).grid(row=0, column=0, columnspan=3, pady=10)

    labels = ["Case ID", "Examiner", "Network CSV", "Auth Log CSV"]
    for i, l in enumerate(labels, start=1):
        tk.Label(root, text=l).grid(row=i, column=0, sticky="w")

    case_entry = tk.Entry(root, width=40)
    examiner_entry = tk.Entry(root, width=40)
    net_entry = tk.Entry(root, width=40)
    log_entry = tk.Entry(root, width=40)

    case_entry.grid(row=1, column=1)
    examiner_entry.grid(row=2, column=1)
    net_entry.grid(row=3, column=1)
    log_entry.grid(row=4, column=1)

    tk.Button(root, text="Browse", command=lambda: browse(net_entry)).grid(row=3, column=2)
    tk.Button(root, text="Browse", command=lambda: browse(log_entry)).grid(row=4, column=2)
    tk.Button(root, text="Run Analysis", command=start).grid(row=5, column=1, pady=10)

    root.mainloop()

# =========================
# ENTRY POINT
# =========================
if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--gui", action="store_true")
    args = parser.parse_args()

    if args.gui:
        gui_mode()
    else:
        run_forensics(
            "network_data.csv",
            "auth_logs.csv",
            "CASE-001",
            "Default Examiner"
        )
